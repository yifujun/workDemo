package com.example.streamJDK8;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.ToString;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.Comparator;import java.util.IntSummaryStatistics;import java.util.List;import java.util.Optional;import java.util.function.Function;import java.util.stream.Collectors;import java.util.stream.Stream;/** * steam容器使用. * 1. 无存储。stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。 * 2. 为函数式编程而生。对stream的任何修改都不会修改背后的数据源，比如对stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新stream。 * 3. 惰式执行。stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。 * 4. 可消费性。stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。 */public class GenerateStream {        @Data                              // set、get    @ToString                          // ToString打印    @NoArgsConstructor                 // 无参构造    @AllArgsConstructor                // 有参构造    private class User {        private String name;        private Integer age;    }        private List<User> newStrings = Arrays.asList(            // name，age            new User("张三", 11),            new User("王五", 20),            new User("王五", 91),            new User("张三", 8),            new User("李四", 44),            new User("李四", 44),            new User("李四", 44)    );    // 转换一下, Arrays.asList之后不能进行add、remove操作    private List<User> list=new ArrayList<>(newStrings);            /**     *  使用流循环操作     */    @Test    public void useStream() {        System.out.println("JAVA 8 前");        for (User user:list) {            System.out.println(user);        }        System.out.println("java 8 Lambda");        list.forEach(usrList -> System.out.println(usrList));                System.out.println("java 8 Stream");        list.stream().forEach(ss -> System.out.println(ss));    }    /**     * 排序     */    @Test    public void sortSteram() {        System.out.println("排序前==");        list.forEach(user -> System.out.println(user));        System.out.println("排序后==");        // Java 8 前        Collections.sort(list, new Comparator<User>() {            @Override            public int compare(User o1, User o2) {                return o1.getAge().compareTo(o2.getAge());            }        });        for (User user:list) {            System.out.println(user);        }        System.out.println("java 8 stream");        list.stream().sorted(Comparator.comparing(User::getAge)).forEach(user -> System.out.println(user));    }    /**     * 过滤 Fileter     */    @Test    public void textFilter() {        // 输入年龄大于50岁的人        System.out.println("过滤前==");        list.forEach(user -> System.out.println(user));        System.out.println("过滤后==");        // java 8前        System.out.println("java 8 前");        for (User user:list) {            if (user.getAge() > 50) {                System.out.println(user);            }        }        // java stream后        System.out.println("java 8 stream");        list.stream().filter((User user) -> user.getAge() > 50).forEach(usr -> System.out.println(usr));    }    /**     *  limit 截断.     */    @Test    public void limit() {        // 从第三个开始截断，只输出前三个        System.out.println("截断前==");        list.forEach(user -> System.out.println(user));        System.out.println("截断后==");        //Java 8 前        System.out.println("java 8 前");        for (int i = 0; i < 3; i++) {            System.out.println(list.get(i));        }        System.out.println("java 8 stream");        list.stream().limit(3).forEach(usr -> System.out.println(usr));    }    /**     * skip 跳过.     * skip()：与limit互斥，使用该方法跳过元素     */    @Test    public void skipStream() {        //跳过前三个元素，从第四个开始输出        System.out.println("跳过前===");        for (User user:list) {            System.out.println(user);        }        System.out.println("跳过后===\n");        System.out.println("Java 8 前");        for (int i = 3;i < list.size(); i++) {            System.out.println(list.get(i));        }        System.out.println("Java 8 stream");        list.stream().skip(3).forEach(user -> System.out.println(user));    }    /**     * 去重     */    @Test    public void distinctStream() {        //数据去重        System.out.println("去重前");        for (User user : list) {            System.out.println(user);        }        System.out.println("去重后\njava 8 之前");        for (int i = 0; i < list.size() - 1; i++) {            for (int j = list.size() - 1; j > i; j--) {                 if (list.get(j).getAge() == list.get(i).getAge()                         && list.get(i).getName().equals(list.get(j).getName())) {                       list.remove(i);                 }            }        }        for (User user : list) {            System.out.println(user);        }        System.out.println("java 8 stream");        list.stream().distinct().forEach(user -> System.out.println(user));    }    /**     *  完成去重+按照年龄大于40以后从小到大+只取前二     */    @Test    public void workSteram() {        System.out.println("完成去重+按照年龄大于40以后从小到大+只取前二 之前 ===");        for (User user:list) {            System.out.println(user);        }        System.out.println("使用 java8 stream 完成去重+按照年龄大于40以后从小到大+只取前二 ==");        list.stream().distinct().filter((User user) -> user.getAge() > 40).sorted(Comparator.comparing(User::getAge)).limit(2)        .forEach(user -> System.out.println(user));    }    /**     * max，min，sum，avg，count      */    @Test    public void functionStream() {        IntSummaryStatistics intSummaryStatistics = list.stream().mapToInt(u -> u.getAge()).summaryStatistics();        System.out.println("总共人数" + intSummaryStatistics.getCount());        System.out.println("分数最多" + intSummaryStatistics.getMax());        System.out.println("分数最少" + intSummaryStatistics.getMin());        System.out.println("平均年龄" + intSummaryStatistics.getAverage());        System.out.println("年龄之和" + intSummaryStatistics.getSum());    }    /**     * map()接收一个方法作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素     */    @Test    public void mapStream() {        // 只输入所有人的年龄        list.stream().forEach(user -> System.out.println(user));        System.out.println("映射后====");        list.stream().map(user -> user.getAge()).collect(Collectors.toList()).forEach(a -> System.out.println(a));                List<String> word = Arrays.asList("aaa","bbb","ccc");        System.out.println("全部大写==");        List<String> collects = word.stream().map(uses -> uses.toUpperCase()).collect(Collectors.toList());        collects.forEach(user -> System.out.println(user));    }    /**     * flatMap.     * 对每个元素执行mapper指定的操作，并用所有mapper返回的Stream中的元素组成一个新的Stream作为最终返回结果，     * 通俗易懂就是将原来的stream中的所有元素都展开组成一个新的stream     * 自己理解： 多个相同类型的Stream 合成 一个 Stream     */    @Test    public void flatMapStream() {        //创建一个 装有两个泛型为integer类型的集合        Stream<List<Integer>> stream = Stream.of(Arrays.asList(1, 2, 3), Arrays.asList(4, 5));        // 将两个合成一个        Stream<Integer> integerStream = stream.flatMap((Function<List<Integer>, Stream<Integer>>) intfuncation -> intfuncation.stream());        List<Integer> integers = integerStream.collect(Collectors.toList());        System.out.println("新stream大小" + integers.size());        integers.forEach(integer -> System.out.println(integer));    }    /**     * 获取list的第一个元素     */    @Test    public void firstStream() {        User user = list.stream().findFirst().get();        System.out.println(user);    }    /**     * reduce 操作可以实现从一组元素中生成一个值     * sum()、max()、min()、count()等都是reduce操作，将他们单独设为函数只是因为常用     */    @Test    public void reduceStream() {        Optional<User> reduce = list.stream().reduce((s1, s2) -> s1.getAge() > s2.getAge() ? s1 : s2);  //年龄最大的  sum        Integer reduce1 = list.stream().reduce(0, // 该参数为初始值                (integer, user) -> integer + user.getAge(), // 该参数为累加器，新元素如何累加                (integer, integer2) -> integer + integer2);// 多个部分如何合并        System.out.println(reduce1);    }    /**     * 使用collect做join拼接操作     */    @Test    public void collectjoinStream() {        Stream<String> stringStream = Stream.of("张三","李四","王五","赵六");        String s2 = stringStream.collect(Collectors.joining("-", "(", ")"));        System.out.println(s2);    }}